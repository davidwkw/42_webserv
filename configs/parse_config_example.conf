server {
listen 8080; 
listen 50;
server_name _;
redirect 301 https://$DOMAIN_NAME;
}
server {
listen 443;
server_name some_name;
root public;
index index.php index.htm index.html;
location / {
index index.html;
}
location /cgi/ {
cgi_bin py /usr/bin/python3
cgi_bin test ./
}
location /test_path/ {
root public/test
}
}
server {
listen 443;
server_name some_name;
root public;
index index.php index.htm index.html ;
location / 
{
index index.html;
}
location /cgi/
{
cgi_bin py /usr/bin/python3
cgi_bin test ./
}
location /test_path/
{
root public/test
}
}


/******************************************************************************

Welcome to GDB Online.
GDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,
C#, OCaml, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.
Code, Compile, Run and Debug online from anywhere in world.

*******************************************************************************/
#include <iostream>
#include <string>
#include <map>

#define WHITESPACE_CHARACTERS " \r\t\v\n\f"

using namespace std;

std::string ltrim_chars(const std::string& str, const std::string &characters)
{
    return str.substr(str.find_first_not_of(characters));
}

std::string rtrim_chars(const std::string& str, const std::string &characters)
{
    return str.substr(0, str.find_last_not_of(characters) + 1);
}

std::string trim_chars(const std::string &str, const std::string &chars)
{
	return ltrim_chars(rtrim_chars(str, chars), chars);
}

std::string str_limit_span(const std::string &str, const char open, const char close){
	std::size_t start_index;
	std::size_t delimiter_index;
	std::size_t pair = 0;
	std::string ret = "";

	if (open == 0 || close == 0 || open == close)
    {
        return ret;
    }
	start_index = str.find_first_of(open);
	if (start_index == std::string::npos)
		return ret;
	pair = 1;
	start_index += 1;
	delimiter_index = start_index;
	while ((pair > 0)
			&& (delimiter_index = str.find_first_of(std::string(1, open) + std::string(1, close), delimiter_index)) != std::string::npos)
	{
		if (str[delimiter_index] == open){
			++pair;
		}
		else if (str[delimiter_index] == close) 
		{
			--pair;
		}
		if (pair == 0)
		{
			break;
		}
		++delimiter_index;
	}
	if (pair > 0)
    	return ret; 
	ret = str.substr(start_index, delimiter_index - start_index);
	return ret;
}

std::multimap<std::string, std::string> parse_block_directives(const std::string &str)
{
	std::multimap<std::string, std::string>	result;
	std::pair<std::string, std::string>		directive_pair;
	std::size_t								start_index = 0;
	std::size_t								delimiter_index = start_index;
	
	while ((delimiter_index = str.find_first_of("{}", delimiter_index)) != std::string::npos)
	{
		if (str[delimiter_index] == '}')
		{
			throw std::runtime_error("[Config]: Found } before {");
		}
		start_index = str.find_last_of('}', delimiter_index);
		start_index %= std::string::npos;
		start_index = (start_index > 0) ? start_index + 1 : start_index;
		directive_pair.first = str.substr(start_index, delimiter_index - start_index);
		directive_pair.first = trim_chars(directive_pair.first, WHITESPACE_CHARACTERS);
		directive_pair.second = str_limit_span(str.c_str() + delimiter_index, '{', '}');
		result.insert(directive_pair);
		delimiter_index += directive_pair.second.size() + 2;
	}
	return result;
}

int main()
{
    string str;
    std::multimap<std::string, std::string> mm;

    str = "server {\nlisten 8080 default_server;\nlisten 50;\nserver_name _;\nredirect 301 https://$DOMAIN_NAME;\n}\nserver {\nlisten 443;\nserver_name some_name;\nroot public;\nindex index.php index.htm index.html ;\nlocation / {\nindex index.html;\n}\nlocation /cgi/ {\ncgi_bin py /usr/bin/python3\ncgi_bin test ./\n}\nlocation /test_path/ {\nroot public/test\n}\n}\nserver {\nlisten 443;\nserver_name some_name;\nroot public;\nindex index.php index.htm index.html ;\nlocation / \n{\nindex index.html;\n}\nlocation /cgi/\n{\ncgi_bin py /usr/bin/python3\ncgi_bin test ./\n}\nlocation /test_path/\n{\nroot public/test\n}\n}\n";
    mm = parse_block_directives(str);
    for (std::multimap<std::string, std::string>::iterator it = mm.begin(); it != mm.end(); it++)
    {
        cout << "===\n" << it->first << "\n===" << endl;
        cout << "===\n" << it->second << "\n===" << endl;
    }

    return 0;
}

listen 443;\nserver_name some_name;\nroot public;\nindex index.php index.htm index.html;\nlocation / \n{\nindex index.html;\n}\nlocation /cgi/\n{\ncgi_bin py /usr/bin/python3\ncgi_bin test ./\n}\nlocation /test_path/\n{\nroot public/test\n}\n
